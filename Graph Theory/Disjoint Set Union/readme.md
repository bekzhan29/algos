# Система непересекающихся множеств

Система непересекающихся множеств позволяет оъединять 2 множества и узнавать в каком множестве находится любая вершина.

Изначально каждая вершина находится в отдельном множестве. У нас будет массив $p$, где $p[i]$ является предком вершины $i$. Корнем каждого множества будет вершина $i$ такая что $p[i]=i$, то есть у нее нет предка. Сначала все $p[i]=i$.

Чтобы найти в каком множестве находится вершина $i$ будем подниматься по предкам пока не найдем его. Это можно сделать следующим образом.
```cpp
int find_root(int a)
{
	if (a == p[a])
		return a;
	return find_root(p[a]);
}
```
Тут 2 случая:  
1. Вершина $a$ является корнем, тогда возвращаем ответ.
2. Иначе рекурсивно находим корень через предка вершины $a$.

Чтобы объединить 2 множества $a$ и $b$ нам надо найти корни их компонент. Далее у нас тоже 2 случая:  
1. Они уже в одной компоненте, тогда нам не нужно ничего делать.
2. Иначе мы можем сделать одну из вершин предком другой, тем самым объединив их компоненты.
```cpp
bool unionn(int a, int b)
{
	a = find_root(a);
	b = find_root(b);
	if (a == b)
		return 0;
	p[b] = a;
	return 1;
}
```

Асимптотика данного кода зависит от высоты на которой находится вершина $a$. То есть время работы $O(h)$, где $h$ это расстояние от корня до вершины $a$. В худшем случае это будет работать за $O(N)$.

<details>
<summary><code>dsu.cpp</code></summary>

1. Построение $O(N)$
2. Найти компоненту $O(1)$
3. Объединить компоненты $O(1)$
</details>
<details>
<summary><code>dsu_tree.cpp</code></summary>

1. Построение $O(NlogN)$
2. Память $O(NlogN)$
3. Найти компоненту в момент времени $T$ $O(logN)$
4. Объединить компоненты $O(logN)$

[Задача](https://atcoder.jp/contests/agc002/tasks/agc002_d)

[Видео](https://www.youtube.com/watch?v=kHxaTXQfu9E&t=2060s) урок от [Um_nik](https://codeforces.com/profile/Um_nik)
</details>
