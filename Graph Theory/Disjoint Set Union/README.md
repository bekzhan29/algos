# Система непересекающихся множеств

Система непересекающихся множеств позволяет оъединять 2 множества и узнавать в каком множестве находится любая вершина.

Изначально каждая вершина находится в отдельном множестве. У нас будет массив $p$, где $p[i]$ является предком вершины $i$. Корнем каждого множества будет вершина $i$ такая что $p[i]=i$, то есть у нее нет предка. Сначала все $p[i]=i$.

Чтобы найти в каком множестве находится вершина $i$ будем подниматься по предкам пока не найдем его. Это можно сделать следующим образом.
```cpp
int find_root(int a)
{
	if (a == p[a])
		return a;
	return find_root(p[a]);
}
```

Тут 2 случая:  
1. Вершина $a$ является корнем, тогда возвращаем ответ.
2. Иначе рекурсивно находим корень через предка вершины $a$.

Чтобы объединить 2 множества $a$ и $b$ нам надо найти корни их компонент. Далее у нас тоже 2 случая:  
1. Они уже в одной компоненте, тогда нам не нужно ничего делать.
2. Иначе мы можем сделать одну из вершин предком другой, тем самым объединив их компоненты.
```cpp
bool union_sets(int a, int b)
{
	a = find_root(a);
	b = find_root(b);
	if (a == b)
		return 0;
	p[b] = a;
	return 1;
}
```
# Solai
Асимптотика данного кода зависит от высоты на которой находится вершина $a$. То есть время работы $O(h)$, где $h$ это расстояние от корня до вершины $a$. В худшем случае это будет работать за $O(N)$.

Первая оптимизация состоит в том чтобы сократить пути до корня. Ниже приведен код как это сделать:
```cpp
int find_root(int a)
{
	if (a == p[a])
		return a;
	return p[a] = find_root(p[a]);
}
```

Вторая оптимизация состоит в том чтобы вместо подвешивания вершины $b$ за $a$ мы будем подвешивать компоненту с меньшим размером за большую. Для этого нам понадобится новый массив $r$, где $r[i]$ хранит размер компоненты с корнем $i$. Изначально сделаем все $r[i]=1$.
```cpp
bool union_sets(int a, int b)
{
	a = find_root(a);
	b = find_root(b);
	if (a == b)
		return 0;
	if (r[a] > r[b])
	{
		r[a] += r[b];
		p[b] = a;
	}
	else
	{
		r[b] += r[a];
		p[a] = b;
	}
	return 1;
}
```

<details>
<summary><code>dsu.cpp</code></summary>

1. Построение $O(N)$
2. Найти компоненту $O(1)$
3. Объединить компоненты $O(1)$
</details>
<details>
<summary><code>dsu_tree.cpp</code></summary>

1. Построение $O(NlogN)$
2. Память $O(NlogN)$
3. Найти компоненту в момент времени $T$ $O(logN)$
4. Объединить компоненты $O(logN)$

[Задача](https://atcoder.jp/contests/agc002/tasks/agc002_d)

[Видео](https://www.youtube.com/watch?v=kHxaTXQfu9E&t=2060s) урок от [Um_nik](https://codeforces.com/profile/Um_nik)
</details>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
