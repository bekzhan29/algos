# Қиылыспайтын жиындар

Қиылыспайтын жиындар екі жиынды біріктіруге және кез келген төбенің қай жиында екенін білуге мүмкіндік береді.

Алғашында әрбір төбе жеке жиында болады. Бізде $p$ массиві болады, мұндағы $p[i]$ төбе $i$-нің атасы болады. Әр жиынның түбірі $p[i]=i$ болатын төбе болады, яғни оның атасы жоқ. Алғашында барлық $p[i]=i$.

Төбе $i$ қай жиында екенін табу үшін оның аталары бойынша көтеріліп, түбірін табамыз. Бұл келесі жолмен жүзеге асырылады:
```cpp
int find_root(int a)
{
    if (a == p[a])
        return a;
    return find_root(p[a]);
}
```

Мұнда 2 жағдай бар:
1. Төбе $a$ түбір болып табылады, сондықтан жауапты қайтарамыз.
2. Әйтпесе, рекурсивті түрде төбе $a$-ның атасы арқылы түбірді табамыз.

Екі жиынды $a$ және $b$ біріктіру үшін олардың түбірлерін табуымыз керек. Одан кейін бізде тағы 2 жағдай бар:
1. Олар бір жиында болса, ештеңе істеудің қажеті жоқ.
2. Әйтпесе, бір төбені екіншісінің атасы етіп, жиындарды біріктіреміз.
```cpp
bool union_sets(int a, int b)
{
    a = find_root(a);
    b = find_root(b);
    if (a == b)
        return 0;
    p[b] = a;
    return 1;
}
```

Бұл кодтың асимптотикасы төбе $a$-ның қандай биіктікте орналасқанына байланысты. Яғни, жұмыс уақыты $O(h)$, мұндағы $h$ түбірден төбе $a$-ға дейінгі қашықтық. Ең нашар жағдайда бұл $O(N)$ болады.

Бірінші оңтайландыру түбірге дейінгі жолдарды қысқартудан тұрады. Мұны келесі код арқылы жүзеге асыруға болады:
```cpp
int find_root(int a)
{
    if (a == p[a])
        return a;
    return p[a] = find_root(p[a]);
}
```

Екінші оңтайландыруда $b$ төбесін $a$ төбесіне ілудің орнына, біз кіші жиынды үлкен жиынға ілеміз. Ол үшін бізге $r$ жаңа массиві қажет, мұндағы $r[i]$ түбірі $i$ болатын жиынның өлшемін сақтайды. Алғашында барлық $r[i]=1$ деп қоямыз.
```cpp
bool union_sets(int a, int b)
{
    a = find_root(a);
    b = find_root(b);
    if (a == b)
        return 0;
    if (r[a] > r[b])
    {
        r[a] += r[b];
        p[b] = a;
    }
    else
    {
        r[b] += r[a];
        p[a] = b;
    }
    return 1;
}
```

<details>
<summary><code>dsu.cpp</code></summary>

1. Құру $O(N)$
2. Жиын түбірін табу $O(1)$
3. Жиындарды қосу $O(1)$
</details>
<details>
<summary><code>dsu_tree.cpp</code></summary>

1. Құру $O(NlogN)$
2. Память $O(NlogN)$
3. Найти компоненту в момент времени $T$ $O(logN)$
4. Жиындарды қосу $O(logN)$

[Задача](https://atcoder.jp/contests/agc002/tasks/agc002_d)

[Видео](https://www.youtube.com/watch?v=kHxaTXQfu9E&t=2060s) урок от [Um_nik](https://codeforces.com/profile/Um_nik)
</details>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
        inlineMath: [['$','$']]
      }
    });
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
