# Money
Note that the numbers in each segment must be non-decreasing, otherwise the final array will be unsorted. Also note that the numbers at positions $i$ and $j$ such that $i<j$ and $a[i] \le a[i+1] \le ... \le a[j-1] \le a[j]$ cannot be in the same segment if there is $k$ such that $k<i$ and $a[i]<a[k]<a[j]$. Because the number $a[k]$ will not be in the same segment with $a[i]$, since $a[k]>a[i]$, and the numbers in the segment must be non-decreasing. This means that the numbers from position $i$ to $j$ will either be all to the left of $k$, or all to the right. If you put the segment $i$, $j$ to the left of $k$, the array will be unsorted since $a[j]>a[k]$. Similarly, if you put the segment $i$, $j$ to the right of $k$, the array will be unsorted because $a[k]>a[i]$.

Let's start from the first position, we will take numbers while the segment is non-decreasing. For subsequent segments, we need to take numbers while they are non-decreasing and none of the numbers from the previous segments is between $a[l]$ and $a[r]$, where $l$ is the beginning of the current segment and $r$ is its end. You can add all the numbers from the previous segments to a set in `C++` and find the minimum number that is greater than $a[l]$, this can be done using `set.upper_bound()`. Let's call this number $x$. We will take numbers into the segment until they are non-decreasing and not greater than $x$.

The running time is $O(NlogN)$.