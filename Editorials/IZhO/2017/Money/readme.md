# Банкноты
Заметим что числа в каждом из отрезков должны неубывать, иначе финальный массив будет неотсортирован. Еще заметим что числа на позициях $i$ и $j$ такие что $i<j$ и $a[i] \le a[i+1] \le ... \le a[j-1] \le a[j]$ не могут быть в одном отрезке если существует такое $k$ что $k<i$ и $a[i]<a[k]<a[j]$. Потому что число $a[k]$ будет не в одном отрезке с $a[i]$, так как $a[k]>a[i]$, а числа в отрезке должны неубывать. Значит числа с позиции $i$ до $j$ будут либо все слева от $k$, либо справа. Если поставить отрезок $i$, $j$ слева от $k$, то массив будет неотсортирован так как $a[j]>a[k]$. Аналогично если поставить отрезок $i$, $j$ справа от $k$, то массив будет неотсортирован потому что $a[k]>a[i]$.

Начнем с первого позиции, будем брать числа пока отрезок неубывает. Для последующих отрезков надо брать числа пока они неубывают и ни одно из чисел из прошлых отрезков не находится между $a[l]$ и $a[r]$, где $l$ это начало текущего отрезка и $r$ его конец. Можно добавить все числа из предыдущих отрезков в сет в `C++` и найти минимальное число которое больше чем $a[l]$, это можно сделать с помощью `set.upper_bound()`. Назовем это число $x$. Будем брать числа в отрезок до тех пор пока они неубывают и не больше чем $x$.

Время работы $O(NlogN)$.